ES6新特性
		1.定义：ECMAScript6.0 是JS语言的下一代标准，于2015-6发布
		2.ES6设计目标：达到JavaScript 语言可以用来编写复杂的大型程序，成为企业级开发语言
		3.ECMAScript 和JavaScript 的关系：ECMAScript 是JavaScript 的规范/规则，JavaScript 是ECMAScript 的一种实现
	let声明变量
		1. let 声明的变量有严格局部作用域
		2. let 只能声明一次, var 可以声明多次
		3. let 不存在变量提升, var 存在变量提升
	const声明常量/只读变量
		1. 常量在定义时，需要赋值
		2. 常量赋值后不能修改
	解构赋值
		基本介绍：1. 解构赋值是对赋值运算符的扩展
				  2. 是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值
				  3. 主要有两种形式： 数组解构和对象解构
		数组解构：
			let [a, b, c] = arr;
			console.log(a, b, c);
			let [num1, num2, num3] = [100, 200, 300];
			console.log(num1, num2, num3);
		对象解构：
			let monster = {name: '牛魔王', age: 800};
			let {name, age} = monster;
			//let {name, age} = {name: '牛魔王', age: 800};
			function f1({name, age}) {
				console.log("f1-name=", name, " ", "f1-age=", age)
			}
			f1(monster);
	模板字符串：
		1.模板字符串使用反引号` 将字符串包裹
		2.可作为普通字符串
		3.可用来定义多行字符串，即可以将换行字符串原生输出
		4.字符串插入变量和表达式, 使用${}
		5.字符串中调用函数
			//1、字符串，换行会原生输出
				let str1 = `for(int i = 0;i < 10;i++){
					System.out.println("i="+i);
				}`;
			//2. 字符串插入变量和表达式。变量名写在${} 中，${} 中可以放入JavaScript 表达式。
				let name = "hspedu 教育";
				//老师解读
				//(1) 当解析${name}, 就找最近的name 遍历, 进行替换
				//(2) 然后可以得到最后解析的字符串
				let str2 = `教育名称=${name}`;
				let str3 = `1+2=${1 + 2}`;
				let n1 = 80;
				let n2 = 20;
				let str4 = `${n1}+${n2}=${n1 + n2}`;
			//3. 字符串中调用函数	
				function sayHi(name) {
					return "hi " + name;
				}
				let name2 = "tom";
				let str5 = `sayHi() 返回的结果是=${sayHi('jack')}`;
				let str6 = `sayHi() 返回的结果是=${sayHi(name2)}`;
	对象相关新特性：
		声明对象简写：
			const age = 800;
			const name = "牛魔王";
			// ES6 声明/定义对象
			//老师解读
			//1. {name, age} : 表示对象的属性名是name 和age
			//2. 属性name 的值是从变量/常量name 来的
			let monster02 = {name, age};
		对象方法简写：
			// ES6-对象方法定义
			let monster2 = {
				name: "红孩儿~",
				age: 900,
				sayHi() {
					console.log("信息: name=", this.name, " age=", this.age);
				},
				f1() {
					console.log("f1()");
				}
			}
			monster2.sayHi();
			monster2.f1();
		对象拓展运算符：
			let cat = {name: "小花猫", age: 2};
			// 拷贝对象(深拷贝)
			let cat2 = {...cat};
			cat2.name = "中花猫";
			console.log("cat=>", cat);//小花猫
			console.log("cat2=>", cat2);//中花猫
			
			// 合并对象[深拷贝]
			let monster = {name: "白骨精", age: 100};
			let car = {brand: "奔驰", price: 800000};
			let monster_car = {...monster, ...car}
			monster_car.name = "狐狸精";
			console.log("monster=>", monster);
			console.log("monster_car=>", monster_car);
	箭头函数：
			1. 箭头函数提供更加简洁的函数书写方式。
			2. 基本语法是：(参数列表) => { 函数体}
			3. 箭头函数没有参数或有多个参数，要用() 括起来,箭头函数只有一个参数, 可以省略()
			4. 箭头函数函数体有多行语句，用{} 包裹起来，表示代码块
			5. 函数体只有一行语句，并且需要返回结果时，可以省略{} , 结果会自动返回
			7. 箭头函数多用于匿名函数的定义
		// ES6 , 箭头函数使用
			let f2 = (n) => {
				return n * 2;
			}
			console.log("f2() 结果= ", f2(100));//200
			//上面的es6 函数写法，还可以简化
			let f3 = n => n * 3;
			
			//函数也可以传给一个变量=> 看看java 基础匿名内部类
			function hi(f4) {
				console.log(f4(900));
			}
			hi((n) => {
				return n + 100
			});
			hi((n) => {
				return n - 100
			});
		箭头函数使用：	
			// ES6 , 箭头函数使用
			let f2 = (n, m) => {
			var res = 0
				for (var i = n; i <= m; i++) {
				  res += i
				}
			 return res
			};
			console.log(f2(1, 10));
			
			let f3 = ({age, name, skill}) => {
				console.log("skill=", skill, " age=", age, " name=", name);
			}
			f3(monster);
			
			2.7.5.1 箭头函数+对象解构, 注意参数是({属性名})
			2.7.5.2 ({属性名}) 是由{} 包括的，属性名需要和对象属性名一致，使用到了对象解构

promise
	基本介绍：Promise 是异步编程的一种解决方案。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。
			  Promise 也是ES6 的新特性，因为比较重要，老师单独拉出来讲
				一句话: Promise 是异步编程的一种解决方案, 可以解决传统Ajax 回调函数嵌套问题
	注意事项和使用细节
		3.2.3.1 如果返回的是Promise 对象，可以继续执行.then()
		3.2.3.2 .then((data)=>{}) 的data 数据是上一次正确执行后resolve(data) 返回传入的
		3.2.3.3 通过多级.then() 可以对异步请求分层次请求，实现代码重排，代码逻辑更加清晰合理
		3.2.3.4 通过多级.then() 后面的.catch((err) => {}) 可捕获发生异常，便于调试
模块化编程
	基本介绍：
		传统非模块化开发有如下的缺点：(1)命名冲突(2)文件依赖
		Javascript 代码越来越庞大，Javascript 引入模块化编程，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块
		Javascript 使用"模块"（module）的概念来实现模块化编程, 解决非模块化编程问题
		模块化也是ES6 的新特性
	ES5模块化编程：
		导出：
			exports = {
				sum,
				sub,
				name,
				PI
			}
		导入：
			//1. 在es5 中, 我们通过require 就包对应.js 中的
			//数据/对象，引入
			//2. 我们使用的时候，通过m.属性就可以使用
			//3. 如果我们导入时，不需要所有的，可以导入部分数据
			const m = require("./function.js");
			const {sub} = require("./function.js");
	    要看运行效果，需要Node 环境, node 环境我们后面搭建, 只要use.js 可以解析sum 和sub 说明是正确的
	ES6 模块编程：
		介绍：
			1、ES6 使用(1)export {名称/对象/函数/变量/常量} (2) export 定义= (3) export default {}导出模块
			2、使用import {} from "xx.js" / import 名称form "xx.js" 导入模块
		ES6 的模块化，需要用Babel 转码ES5 后再执行, 我们后面在整体项目中使用即可, 只要es6_use.js 可以识别变量名说明是正确的
		方式一：选择导出
			导出：
				exports = {
					sum,
					sub,
					name,
					PI
				}
			导入：
			/**
				* 老韩解读
				* 1. 我可以{} 来接收导出的数据
				* 2. 可以全部接收，也可以选择的接收
				* 3. 细节： 这时要求导入的名称和导出的名称一致
			*/
				import {sub,sum,name} from "./common";
				import {monster} from "./common";
		方式二：定义时导出
			导出：
				//定义sum 函数时，就直接导出
				//老韩说明：如果在定义时，导出的数据， 在导入时，要保持名字一致
				export const sum = function (a, b) {
					return parseInt(a) + parseInt(b);
				}
			导入：
				//可以导入模块/数据
				import {sum} from "./common2";
				//没有导出的数据, 是不可以导入
				//import {sub} from "./common2";
		方式三：默认导出
			导出：
				export default {
					sum(a,b) {
						return parseInt(a) + parseInt(b);
					},
					sub(a,b) {
						return parseInt(a) - parseInt(b);
					}
				}
			导入：
				//导入默认导出模块/数据
				//好处是m 名称是可以自己指定的.
				//因为m 名字, 程序员可以自己指定，因此我们就可以解决名称冲突问题
				import m from "./common3";
		注意事项和使用细节：
			ES6 的模块化无法在Node.js 中执行，需要用Babel 转码ES5 后再执行
			export 不仅可以导出对象，一切JS 变量都可以导出。比如：基本类型变量、函数、数组、对象
			没有导出的不能使用
			es6 有导出方式较多, 不同的导出方式对导入方式也有一定影响
Vue
	基本介绍：
		1.Vue (读音/vjuː/，类似于view) 是一个前端框架, 易于构建用户界面
		2. Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或项目整合
		3. 支持和其它类库结合使用
		4. 开发复杂的单页应用非常方便
		5. Vue 是Vue.js 的简称
		后面我们也讲解Vue3 的使用， 在学习SSM 时，我们使用SSM 框架(Vue3+ElementPlus+Axios+SSM 前后端分离)
	MVVM：
		M∶即Model，模型，包括数据和一些基本操作
 		V∶即View，视图，页面渲染结果
 		VM∶即View-Model，模型与视图间的双向操作(无需开发人员干涉)在MVVM之前，开发人员从后端获取需要的数据模型，然后要通过DOM 操作Model
			渲染到View 中。而后当用户操作视图，我们还需要通过DOM获取View 中的数据，然后同步到Model 中。
 		而MVVM中的VM 要做的事情就是把DOM 操作完全封装起来，开发人员不用再关心Model 和View 之间是如何互相影响的。
		只要我们Model 发生了改变，View上自然就会表现出来当用户修改了View，Model 中的数据也会跟着改变。。
 	  结果：把开发人员从繁琐的DOM操作中解放出来，把关注点放在如何操作Model上, 大大提高开发效率

	快速入门：
		1. 创建新文件夹D:\idea_java_projects\vue , 直接拖到Idea 工具，使用idea 打开
		2. 将下载好的vue.js 拷贝到D:\idea_java_projects\vue\vue.js
		3. 创建D:\idea_java_projects\vue\vue_quick_start.html
		
		<div id="app">
		<!--老师解读
		1. {{message}} : 插值表达式
		2. message 就是从model 的data 数据池来设置
		3. 当我们的代码执行时，会到data{} 数据池中去匹配数据, 如果匹配上, 就进行替换
		, 如果没有匹配上, 就是输出空
		-->
			<h1>欢迎你{{message}}-{{name}}</h1>
		</div>
		<!--引入vue.js-->
		<script src="vue.js"></script>
		<script>
		//创建Vue 对象
		/**
		* 老韩解读
		* 1. 创建Vue 对象实例
		* 2. 我们在控制台输出vm 对象，看看该对象的结构！(data/listeners)
		*
		*/
		let vm = new Vue({
			el: "#app", //创建的vue 实例挂载到id=app 的div
			data: { //data{} 表示数据池(model 的有了数据), 有很多数据,以k-v 形式设置(根据业务需要来设置)
				message: "Hello-Vue!",
				name: "韩顺平教育"
			}
		})
		</script>
	注意事项和使用细节
		1. 注意代码顺序，要求div 在前，script 在后，否则无法绑定数据
		2. 从案例可以体会声明式渲染：Vue.js 采用简洁的模板语法来声明式地将数据渲染进DOM 的系统， 做到数据和显示分离
		3. Vue 没有繁琐的DOM 操作，如果使用jQuery，我们需要先找到div 节点，获取到DOM对象，然后进行节点操作, 显然Vue 更加简洁
	数据单向渲染
		v-bind 指令可以完成基本数据渲染/绑定;简写形式就是一个冒号（:）
		<img v-bind:src="img_src" v-bind:width="img_width">
		data: { //data{} 表示数据池(model 的有了数据), 有很多数据,以k-v形式设置(根据业务需要来设置)
			message: "hello, 耗子精",
			img_src: "1.jpg",
			img_width: "200px"
		}
	数据双向绑定
		v-model 可以完成双向数据绑定
		<input type="text" v-model="hobby.val"><br/><br/>
		data: { //data{} 表示数据池(model 的有了数据), 有很多数据,以k-v形式设置(根据业务需要来设置)
			hobby: {
				val: "购物"
			}
		}
	事件绑定
		使用v-on 进行事件处理，比如: v-on:click 表示处理鼠标点击事件
		事件调用的方法定义在vue 对象声明的methods 节点中
		<!--老韩解读
		1. v-on:click 表示我们要给button 元素绑定一个click 的事件
		2. sayHi() 表示绑定的方法, 在方法池methods{} 定义的
		3. 底层仍然是dom 处理
		4. 如果方法不需要传递参数，可以省略()
		5. v-on:click 可以简写@, 但是需要浏览器支持
		-->
		<button v-on:click="sayHi">点击输出</button>
		<button @click="sayOk">点击输出</button>
		//老师解读:
		// 1. 是一个methods 属性, 对应的值是对象{}
		// 2. 在{} 中, 可以写很多的方法, 你可以这里理解是一个方法池
		// 3. 这里需要小伙伴有js 的基础=>java web 第4 章
		methods: {
			sayHi() {
				console.log("hi, 银角大王~");
			},
			sayOk() {
				console.log("ok, 金角大王~");
			}
		}
	修饰符
		修饰符(Modifiers) 是以(.)指明的后缀，指出某个指令以特殊方式绑定。
		例如，.prevent 修饰符告诉v-on 指令对于触发的事件调用event.preventDefault()即阻止事件原本的默认行为
		一句话: 修饰符(Modifiers) 是以（.）指明的后缀，指出某个指令以特殊方式绑定
		https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6
	条件渲染/控制: v-if v-show
		v-if 会确保在切换过程中，条件块内的事件监听器和子组件销毁和重建
		v-show 机制相对简单, 不管初始条件是什么，元素总是会被渲染，并且只是对CSS 进行切换
		使用建议：如果要频繁地切换，建议使用v-show ；如果运行时条件很少改变，使用v-if 较好
	列表渲染: v-for
		<h1>简单的列表渲染-带索引</h1>
		<ul>
			<li v-for="(i,index) in 3">{{i}}-{{index}}</li>
		</ul>
		<h1>遍历数据列表</h1>
		<!-- 语法:
			<tr v-for="对象in 对象数组">
				<td>{{对象的属性}}</td>
			</tr>
		-->
		<table width="400px" border="1px">
		<tr v-for="(monster,index) in monsters">
			<td>{{index}}</td>
			<td>{{monster.id}}</td>
			<td>{{monster.name}}</td>
			<td>{{monster.age}}</td>
		</tr>
		data: { //数据池
			monsters: [
				{id: 1, name: '牛魔王', age: 800},
				{id: 2, name: '黑山老妖', age: 900},
				{id: 3, name: '红孩儿', age: 200}
			]
		}
	组件化编程
		 组件(Component) 是Vue.js 最强大的功能之一(可以提高复用性[1.界面2.业务处理])
		 组件也是一个Vue实例，也包括∶ data、methods、生命周期函数等
		 组件渲染需要html模板，所以增加了template 属性，值就是HTML 模板
		 对于全局组件，任何vue 实例都可以直接在HTML 中通过组件名称来使用组件
		 data 是一个函数，不再是一个对象， 这样每次引用组件都是独立的对象/数据
		全局组件
			<div id="app">
				<h1>组件化编程-全局组件</h1>
				<!--使用全局组件-->
				<counter></counter>
				<br/>
				<counter></counter>
				<counter></counter>
				<counter></counter>
				<counter></counter>
			</div>
			//1、定义一个全局组件, 名称为counter
			//2. {} 表示就是我们的组件相关的内容
			//3. template 指定该组件的界面, 因为会引用到数据池的数据，所以需要是模板字符串
			//4. 这里老师说明: 要把组件视为一个Vue 实例，也有自己的数据池和methods
			//5. 这里老师说明: 对于组件，我们的数据池的数据，是使用函数/方法返回[目的是为了保证每个组件的数据是独立], 不能使用原来的方式
			//6. 这时我们达到目前，界面通过template 实现共享,业务处理也复用
			//7. 全局组件是属于所有vue 实例，因此，可以在所有的vue 实例使用
			Vue.component("counter", {
				template: `<button v-on:click="click()">点击次数= {{count}} 次【全局组件化】</button>`,
				data() {//这里需要注意，和原来的方式不一样!!!!
					return {
						count: 10
					}
				},
					methods: {
						click() {
							this.count++;
						}
					}
				})
			//创建Vue 实例，必须有
			let vm = new Vue({
				el: "#app"//Vue 实例的挂载点
			})
			let vm2 = new Vue({
				el: "#app2"//Vue 实例的挂载点
			})
		局部组件
			<div id="app">
				<h1>组件化编程-局部组件</h1>
				<!--使用局部组件,该组件是从挂载到app 的vue 中的-->
				<my_counter></my_counter><br/>
				<my_counter></my_counter><br/>
				<my_counter></my_counter><br/>
			</div>
			//定义一个组件, 组件的名称为buttonCounter
			//老韩扩展
			//1. 可以把常用的组件，定义在某个commons.js 中export
			//2. 如果某个页面需要使用， 直接import
			const buttonCounter = {
				template: `<button v-on:click="click()"> 点击次数= {{count}} 次【局部组件化】</button>`,
				data() {//这里需要注意，和原来的方式不一样!!!!
					return {
						count: 10
					}
				},
				methods: {
					click() {
						this.count++;
					}
				}
			}
			let vm = new Vue({
				el: "#app",//Vue 实例的挂载点
				components: { //引入/注册某个组件, 此时my_counter 就是一个组件, 是一个局部组件,他的使用范围在当前vue
				'my_counter': buttonCounter
				}
			})			
		5.10.3 组件化小结
		5.10.3.1 组件也是一个Vue 实例，因此它的定义是也存在∶ data、methods、生命周期函数等
		5.10.3.2 data 是一个函数，不再是一个对象， 这样每次引用组件都是独立的对象/数据
		5.10.3.3 组件渲染需要html 模板，所以增加了template 属性，值就是HTML 模板
	生命周期和监听函数(钩子函数)
		1) new Vue()
			new 了一个Vue 的实例对象，此时就会进入组件的创建过程。
		2) Init Events & Lifecycle
			初始化组件的事件和生命周期函数
		3) beforeCreate
			组件创建之后遇到的第一个生命周期函数，这个阶段data 和methods 以及dom 结构都未被初始化，也就是获取不到data 的值，
			不能调用methods 中的函数
		4) Init injections & reactivity
			这个阶段中, 正在初始化data 和methods 中的方法
		5) created
			- 这个阶段组件的data 和methods 中的方法已初始化结束，可以访问，但是dom 结构未初始化，页面未渲染
			- 老师说明：在这个阶段，经常会发起Ajax 请求
		6) 编译模板结构(在内存)
		7) beforeMount
			当模板在内存中编译完成，此时内存中的模板结构还未渲染至页面上，看不到真实的数据
		8) Create vm.$el and replace ‘el’ with it
			这一步，再在把内存中渲染好的模板结构替换至真实的dom 结构也就是页面上
		9) mounted
			此时，页面渲染好，用户看到的是真实的页面数据， 生命周期创建阶段完毕，进入到了运行中的阶段
		10) 生命周期运行中
		10.1 beforeUpdate
			当执行此函数，数据池的数据新的，但是页面是旧的
		10.2 Virtual DOM re-render and patch
			根据最新的data 数据，重新渲染内存中的模板结构，并把渲染好的模板结构，替换至页面上
		10.3 updated
			页面已经完成了更新，此时，data 数据和页面的数据都是新的
		11) beforeDestroy
			当执行此函数时，组件即将被销毁，但是还没有真正开始销毁，此时组件的data、methods数据或方法还可被调用
		12) Teardown……
			注销组件和事件监听
		13) destroyed
			组件已经完成了销毁
Vue2 脚手架模块化开发
	文档地址: https://cli.vuejs.org/zh/
Axios
	6.12 基本说明
		6.12.11 axios 是独立于vue 的一个项目，不是Vue 的一部分
		6.12.12 axios 通常和Vue 一起使用，实现Ajax 操作
		6.12.13 Axios 是一个基于promise 的HTTP 库	
	6.13 学习文档
		6.13.11 https://javasoho.com/axios/
	快速入门：
		//文档引入
		<script src="vue.js"></script>
		<script src="axios.min.js"></script>
		//发出ajax请求
		axios.get('http://localhost:63342/axios/response.data.json')
		.then(response => {
			console.log(response)
			this.monsterList = response.data.data.items
		})
		.catch(error => {
			console.log(error)
		})
		//response.data.data.items
		response.data==》请求到的JSON数据
		response.data.data==》JSON数据里面的data属性值，里面有很多数据对象
		response.data.data.items==》获取数据对象中属性名为items的属性值
		